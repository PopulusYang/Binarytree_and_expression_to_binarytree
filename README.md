# 《二叉树类模板与表达式处理函数使用说明文档》

## 说明

本代码实现了一个二叉树类模板，以及一些与二叉树相关的辅助函数。

## 依赖

- C++11 及以上版本
- CMake 3.10 及以上版本
- g++ 7.4.0 及以上版本

## 目录

- [说明](#说明)
- [依赖](#依赖)
- [二叉树类模板](#二叉树类模板)
  - [概述](#概述)
  - [类模板介绍](#类模板介绍)
    - [TreeNode 类模板](#treenode-类模板)
    - [array 类模板](#array-类模板)
    - [BinaryTree 类模板](#binarytree-类模板)
  - [全局变量](#全局变量)
  - [使用示例](#使用示例)
- [表达式处理](#表达式处理)
  - [std_expression 函数](#std_expression-函数)
  - [infixToPostfix 函数](#infixtopostfix-函数)
  - [PostfixtoBT 函数](#postfixtobt-函数)
  - [食用栗子](#食用栗子)

## 二叉树类模板

### 概述

本代码实现了一个二叉树数据结构，包含节点类 `TreeNode`、辅助类 `array` 以及二叉树类 `BinaryTree`。二叉树中的每个节点存储特定类型的数据，并具有指向左右子节点和双亲节点的指针。提供了多种操作二叉树的方法，如添加节点、遍历二叉树等，同时还具备调试信息输出功能，可通过全局变量 `debug` 控制。

### 类模板介绍

#### `TreeNode` 类模板

- **功能**：表示二叉树的节点。
- **数据成员**：
  - `data`：存储节点的数据，类型为模板参数 `T`。
  - `left`：指向左子节点的指针，类型为 `TreeNode<T>`。
  - `right`：指向右子节点的指针，类型为 `TreeNode<T>`。
  - `parent`：指向双亲节点的指针，类型为 `TreeNode<T>`。
- **成员函数**：
  - `TreeNode(T value)`：构造函数，接受一个 `T` 类型的值来初始化节点数据，并在调试模式下输出节点创建信息。
  - `Iterator_left(TreeNode<T> *&current)`：将当前指针 `current` 移动到左子节点（若存在），若左子节点不存在则返回 `ERROR`，否则返回 `OK`。
  - `Iterator_right(TreeNode<T> *&current)`：将当前指针 `current` 移动到右子节点（若存在），若右子节点不存在则返回 `ERROR`，否则返回 `OK`。
  - `Iterator_parent(TreeNode<T> *&current)`：将当前指针 `current` 移动到双亲节点（若存在），若双亲节点不存在则返回 `ERROR`，否则返回 `OK`。

#### `array` 类模板

- **功能**：提供一些与二叉树节点操作相关的辅助功能。
- **数据成员**：
  - `current`：指向当前节点的指针，类型为 `TreeNode<T>`，初始化为 `nullptr`。
- **成员函数**：
  - `array()`：构造函数，在调试模式下输出自身创建信息。
  - `addNode_left(T data)`：尝试在当前节点添加左子节点，若当前节点左子节点为空，则创建新的 `TreeNode` 并将其作为左子节点，同时设置双亲指针，成功返回 `OK`，若左子节点已存在则返回 `ERROR`。
  - `addNode_right(T data)`：尝试在当前节点添加右子节点，若当前节点右子节点为空，则创建新的 `TreeNode` 并将其作为右子节点，同时设置双亲指针，成功返回 `OK`，若右子节点已存在则返回 `ERROR`。
  - `setvalue(T value)`：若当前节点不为空，则设置当前节点的数据值为传入的 `value`，成功返回 `OK`，若当前节点为空则返回 `ERROR`。

#### `BinaryTree` 类模板

- **功能**：表示整个二叉树结构，继承自 `array<T>` 类。
- **数据成员**：
  - `root`：指向二叉树根节点的指针，类型为 `TreeNode<T>`。
- **成员函数**：
  - `BinaryTree(T value = 0)`：构造函数，创建根节点并将其数据初始化为传入的值（默认为 0），同时将 `array<T>` 中的 `current` 指针指向根节点，并在调试模式下输出二叉树创建信息。
  - `~BinaryTree()`：析构函数，调用 `Destroy` 函数释放二叉树的所有节点，并在调试模式下输出二叉树销毁信息。
  - `Iterator_reset()`：将 `array<T>` 中的 `current` 指针重置为根节点。
  - `Destroy(TreeNode<T> *root)`：递归地释放二叉树节点内存。通过栈辅助实现非递归的后序遍历释放节点。从根节点开始，先将当前节点及其左子树节点依次压入栈，当左子树遍历完后，处理右子树，最后释放当前节点。
  - `static std::vector<T> preOrder(BinaryTree<T>& tree)`：静态成员函数，实现二叉树的前序遍历。返回一个包含二叉树所有节点数据的 `std::vector`，遍历顺序为根节点、左子树、右子树。使用栈来辅助实现非递归遍历，先将根节点压入栈，然后循环弹出栈顶节点，将其数据加入结果向量，再依次将右子节点和左子节点压入栈（若存在）。
  - `static std::vector<T> inOrder(BinaryTree<T>& tree)`：静态成员函数，实现二叉树的中序遍历。返回一个包含二叉树所有节点数据的 `std::vector`，遍历顺序为左子树、根节点、右子树。使用栈来辅助实现非递归遍历，从根节点开始，先将当前节点及其左子树节点依次压入栈，当左子树遍历完后，弹出栈顶节点（即当前节点），将其数据加入结果向量，然后转向右子树继续遍历。
  - `static std::vector<T> postOrder(BinaryTree<T>& tree)`：静态成员函数，实现二叉树的后序遍历。返回一个包含二叉树所有节点数据的 `std::vector`，遍历顺序为左子树、右子树、根节点。使用栈和一个标记节点来辅助实现非递归遍历，从根节点开始，先将当前节点及其左子树节点依次压入栈，当左子树遍历完后，若右子树存在且未被访问，则转向右子树，否则弹出栈顶节点，将其数据加入结果向量，并标记该节点已访问。

### 全局变量

- `debug`：布尔类型，用于控制是否输出调试信息。当 `debug` 为 `true` 时，在节点创建、二叉树创建、节点销毁等操作时会输出相应的调试信息。

### 使用示例

以下是一个简单的使用示例，展示如何创建二叉树、添加节点以及进行遍历：

```cpp
#include "binarytree.hpp"

int main()
{
    // 创建一个二叉树，根节点数据为 1
    BinaryTree<int> tree(1);

    // 在根节点添加左子节点，数据为 2
    tree.addNode_left(2);
    // 在根节点添加右子节点，数据为 3
    tree.addNode_right(3);

    // 将当前指针移动到根节点的左子节点
    tree.current->Iterator_left(tree.current);
    // 在当前节点（即根节点的左子节点）添加左子节点，数据为 4
    tree.addNode_left(4);
    // 在当前节点添加右子节点，数据为 5
    tree.addNode_right(5);

    // 将当前指针移动回根节点
    tree.current->Iterator_parent(tree.current);
    // 将当前指针移动到根节点的右子节点
    tree.current->Iterator_right(tree.current);
    // 在当前节点（即根节点的右子节点）添加左子节点，数据为 6
    tree.addNode_left(6);
    // 在当前节点添加右子节点，数据为 7
    tree.addNode_right(7);

    // 前序遍历二叉树并输出节点数据
    std::vector<int> preorderResult = BinaryTree<int>::preOrder(tree);
    std::cout << "Preorder traversal: ";
    for (int i : preorderResult)
        std::cout << i << " ";
    std::cout << std::endl;

    return 0;
}
```

- 在上述示例中，首先创建了一个根节点数据为 1 的二叉树，然后逐步添加子节点构建二叉树结构，最后分别进行了前序遍历并输出结果。通过修改 `debug` 变量的值，可以控制是否输出调试信息，以便在开发和调试过程中观察二叉树的创建、销毁以及节点操作的过程。

- 注意：在实际使用中，应确保根据需要正确处理模板参数 `T` 的类型，以及合理地管理二叉树的内存，避免出现内存泄漏或悬空指针等问题。同时，代码中的 `Stack` 类模板未给出完整定义，如果在使用过程中出现与 `Stack` 相关的问题，需要进一步检查和完善 `Stack` 类模板的实现。

## 表达式处理

以下是对上述代码中几个主要函数的使用说明：

### `std_expression` 函数

- **功能**：对输入的数学表达式字符串进行标准化处理，主要处理负号相关的特殊情况，包括负号前缀（如 `-3` 可能转换为 `(0-3)`）、连续正负号（如 `--3` 转换为 `3`，`+-3` 转换为 `(0-3)`）以及负号后缀（如 `3-` 转换为 `3-(0)`）等情况，使表达式在后续处理中更规范统一。
- **参数**：
  - `expression`：输入输出参数，传入需要处理的原始数学表达式字符串，在函数内部会对其进行修改，将其中的负号相关情况按照规则转换，处理完成后该字符串即为标准化后的表达式。
- **示例用法**：

```cpp
std::string expr = "3-(-5+2)*3";
std_expression(expr);
// 此时 expr 被修改为 "3-(0-(5+2))*3"
```

### `infixToPostfix` 函数

- **功能**：将中缀表达式转换为后缀表达式。中缀表达式是常见的数学表达式书写形式（如 `3 + 4 * 2`），而后缀表达式将运算符放在操作数之后（如 `3 4 2 * +`），这种形式在构建二叉树等后续处理中更方便。该函数按照运算符优先级以及括号规则进行转换，遇到数字直接输出到后缀表达式字符串，遇到运算符则根据栈中已有运算符的优先级决定是否入栈或弹出已有运算符到后缀表达式字符串。
- **参数**：
  - `exp`：输入参数，需要转换的中缀表达式字符串。
- **返回值**：
  - 返回转换后的后缀表达式字符串，其中数字和运算符之间用空格分隔，方便后续处理时按空格分割提取信息。
- **示例用法**：

```cpp
std::string infix = "3*(4+2)/5";
std::string postfix = infixToPostfix(infix);
// 此时 postfix 的值为 "3 4 2 + * 5 / "
```

### `PostfixtoBT` 函数

- **功能**：将后缀表达式转换为二叉树。该函数扫描后缀表达式字符串，遇到数字则创建一个包含该数字的二叉树节点并压入栈中，遇到运算符则从栈中弹出两个节点作为左右子节点，创建一个包含该运算符的新节点，构建好子树关系后将新节点压入栈中，最后栈中剩下的唯一节点即为二叉树的根节点，以此构建出完整的二叉树结构。
- **参数**：
  - `postfix`：输入参数，需要转换为二叉树的后缀表达式字符串，要求数字和运算符之间用空格分隔（与 `infixToPostfix` 函数返回的后缀表达式格式一致）。
- **返回值**：
  - 返回构建好的 `BinaryTree<std::string>` 对象，其内部节点数据类型为 `std::string`，可以存储数字或运算符等信息。
- **示例用法**：

```cpp
std::string postfixExpr = "3 4 + 2 *";
BinaryTree<std::string> tree = PostfixtoBT(postfixExpr);
// 此时 tree 即为构建好的二叉树，可以通过 tree 的相关成员函数（如 display 函数，如果已定义）来查看二叉树结构或进行其他操作
```

在使用这些函数时，一般先调用 `std_expression` 函数对原始中缀表达式进行标准化处理，然后将处理后的表达式传入 `infixToPostfix` 函数得到后缀表达式，最后将后缀表达式传入 `PostfixtoBT` 函数构建二叉树，这样就完成了从原始数学表达式到二叉树结构的转换过程，后续可以基于构建好的二叉树进行表达式求值、表达式化简等其他操作（如果相应功能函数已实现）。

注意，在实际使用中，如果表达式格式错误（如中缀表达式括号不匹配、后缀表达式运算符和操作数数量不匹配等），`infixToPostfix` 函数和 `PostfixtoBT` 函数会输出错误信息并抛出异常，调用代码需要使用 `try-catch` 块来捕获异常并进行相应的错误处理，以保证程序的稳定性。例如：

```cpp
try {
    std::string expr = "3*(4+2)/5";
    std_expression(expr);
    std::string postfix = infixToPostfix(expr);
    BinaryTree<std::string> tree = PostfixtoBT(postfix);
    // 若上述过程无异常，则继续进行其他操作，如查看二叉树结构
    tree.display(); 
} catch (const std::runtime_error &e) {
    std::cerr << "Error: " << e.what() << std::endl;
}
```

通过上述使用说明，可以在程序中合理地调用这些函数来实现数学表达式到二叉树的转换以及相关处理操作，方便在涉及表达式处理和二叉树数据结构应用的场景中使用。

### 食用栗子

以下是一个使用上述函数将数学表达式转换为二叉树的完整示例，示例中的表达式为 `3*(4+2)/5`，下面展示逐步转换的过程：

### 1. 原始表达式

首先有一个中缀表达式 `3*(4+2)/5`。

### 2. 标准化表达式（调用 `std_expression` 函数）

```cpp
#include <iostream>
#include <string>
#include "exptobinarytree.hpp"

int main() {
    std::string expression = "3*(4+2)/5";
    std_expression(expression);
    std::cout << "After std_expression: " << expression << std::endl;
    return 0;
}
```

在这个步骤中，`std_expression` 函数会处理表达式中可能存在的负号相关特殊情况，虽然我们的原始表达式 `3*(4+2)/5` 里没有涉及负号相关特殊处理的部分，但按照函数逻辑走一遍后，表达式保持原样，即输出还是 `3*(4+2)/5`。

### 3. 中缀表达式转后缀表达式（调用 `infixToPostfix` 函数）

```cpp
#include <iostream>
#include <string>
#include "exptobinarytree.hpp"

int main() {
    std::string expression = "3*(4+2)/5";
    std_expression(expression);
    std::string postfix = infixToPostfix(expression);
    std::cout << "After infixToPostfix: " << postfix << std::endl;
    return 0;
}
```

在 `infixToPostfix` 函数中，按照运算符优先级以及括号规则进行转换，扫描中缀表达式，数字直接输出到后缀表达式字符串，运算符根据栈内已有运算符优先级决定入栈或弹出已有运算符到后缀表达式字符串。对于表达式 `3*(4+2)/5`，转换后的后缀表达式为 `3 4 2 + * 5 /` （数字和运算符之间用空格分隔）。

### 4. 后缀表达式转二叉树（调用 `PostfixtoBT` 函数）

```cpp
#include <iostream>
#include <string>
#include "exptobinarytree.hpp"

int main() {
    std::string expression = "3*(4+2)/5";
    std_expression(expression);
    std::string postfix = infixToPostfix(expression);
    try {
        BinaryTree<std::string> tree = PostfixtoBT(postfix);
        // 这里假设 BinaryTree 类有 display 之类的函数用于查看二叉树结构，实际可按具体实现进行后续操作
        // tree.display(); 
    } catch (const std::runtime_error &e) {
        std::cerr << "Error: " << e.what() << std::endl;
    }
    return 0;
}
```

`PostfixtoBT` 函数扫描后缀表达式字符串 `3 4 2 + * 5 /`，遇到数字就创建包含该数字的二叉树节点并压入栈中，遇到运算符则从栈中弹出两个节点作为左右子节点，创建包含该运算符的新节点，构建好子树关系后将新节点压入栈中。最后栈中剩下的唯一节点就是二叉树的根节点，以此构建出完整的二叉树结构，代表了原表达式 `3*(4+2)/5` 的运算逻辑关系。

整个流程总结起来就是：先对原始中缀表达式（如果有需要）进行标准化处理，接着将其转换为后缀表达式，最后再把后缀表达式转换为二叉树，这样就完成了从表达式到二叉树的转换过程。后续如果有相关功能函数实现（比如基于二叉树进行表达式求值等），就可以继续基于构建好的二叉树做进一步操作了。

注意，在实际运行代码时，如果表达式格式不符合函数要求（比如括号不匹配、后缀表达式中运算符和操作数数量关系不对等情况），`infixToPostfix` 函数和 `PostfixtoBT` 函数会输出错误信息并抛出异常，所以在调用这些函数时，建议像示例中那样使用 `try-catch` 块来捕获异常并进行相应的错误处理，保证程序的稳定性。

以下是一种使用文本形式将上述从表达式转换为二叉树的过程可视化呈现的方式，我们依旧以表达式 `3*(4 + 2)/5` 为例：

### 1. 原始中缀表达式

`3*(4 + 2)/5`

用树状结构简单示意（还未真正构建二叉树，只是从逻辑上表示各部分的层次关系，以下用括号来体现层次）：

```cmd
        (*)
      /    \
    (3)    (/)
          /   \
        (+)     (5)
      /   \
    (4)    (2)
```

### 2. 标准化表达式

此表达式无需要处理的负号相关特殊情况，所以表达式依然为：

`3*(4 + 2)/5`

树状结构也保持不变：

```cmd
        (*)
      /    \
    (3)    (/)
          /   \
        (+)     (5)
      /   \
    (4)    (2)
```

### 3. 中缀表达式转后缀表达式

转换后的后缀表达式为 `3 4 2 + * 5 /`。

我们可以想象构建二叉树的过程如下（这里以操作步骤来展示，每一步操作对应二叉树节点的添加和关系构建）：

- 首先扫描后缀表达式，遇到数字 `3`，创建一个二叉树节点并压入栈中，此时栈内节点表示为：`[3]`（这里 `[ ]` 表示栈，里面是栈内的节点）。

- 接着遇到数字 `4`，创建节点并压入栈，栈变为：`[3, 4]`。

- 再遇到数字 `2`，同样创建节点入栈，栈为：`[3, 4, 2]`。

- 遇到运算符 `+`，从栈中弹出两个节点（此时是 `2` 和 `4`）作为左右子节点，创建一个包含 `+` 的新节点，构建好子树关系后将新节点压入栈，栈变为：`[3, (4 + 2)]`（这里用括号表示构建好的子树关系）。

- 遇到运算符 `*`，再从栈中弹出两个节点（现在是 `(4 + 2)` 和 `3`）构建新节点，栈变为：`[(3 * (4 + 2))]`。

- 遇到数字 `5`，创建节点入栈，栈为：`[(3 * (4 + 2)), 5]`。

- 最后遇到运算符 `/`，弹出两个节点构建包含 `/` 的新节点，最终栈中剩下的唯一节点就是二叉树的根节点，此时栈为：`[(3 * (4 + 2)) / 5]`，代表构建好的完整二叉树结构。

用树状结构可视化呈现构建好的二叉树如下：

```cmd
                    (/)
                  /    \
                (*)      (5)
              /    \
            (3)      (+)
                    /   \
                  (4)    (2)
```

### 4. 后缀表达式转二叉树

这一步其实和上一步在构建二叉树的过程本质是一样的，不过从代码实现角度更严谨地去看每一步操作：

下面以表格形式展示每一步扫描后缀表达式以及栈和二叉树构建的情况（`nodeStack` 表示节点栈，`操作` 列表示当前扫描到后缀表达式的元素后进行的操作，`二叉树结构示意（简略）` 列用简单的括号形式表示当前二叉树大概的结构）：

| 扫描位置 | 后缀表达式元素 | nodeStack（栈内节点情况，从栈底到栈顶） | 操作 | 二叉树结构示意（简略） |
|:----:|:----:|:----:|:----:|:----:|
| 开始 | `3 4 2 + * 5 /` | 空 | - | 空 |
| 1 | `3` | `[TreeNode("3")]` | 遇到数字，创建节点入栈 | `(3)` |
| 2 | `4` | `[TreeNode("3"), TreeNode("4")]` | 遇到数字，创建节点入栈 | `(3) (4)` |
| 3 | `2` | `[TreeNode("3"), TreeNode("4"), TreeNode("2")]` | 遇到数字，创建节点入栈 | `(3) (4) (2)` |
| 4 | `+` | `[TreeNode("3"), TreeNode("(4 + 2)")]` | 遇到运算符，弹出两个节点构建新节点入栈 | `(3) (4 + 2)` |
| 5 | `*` | `[TreeNode("(3 * (4 + 2))")]` | 遇到运算符，弹出两个节点构建新节点入栈 | `(3 * (4 + 2))` |
| 6 | `5` | `[TreeNode("(3 * (4 + 2)")], TreeNode("5")` | 遇到数字，创建节点入栈 | `(3 * (4 + 2)) (5)` |
| 7 | `/` | `[TreeNode("((3 * (4 + 2)) / 5)")]` | 遇到运算符，弹出两个节点构建新节点入栈，此时栈只剩根节点，二叉树构建完成 | `((3 * (4 + 2)) / 5)` |

最终构建好的二叉树可视化结构和上面步骤 3 中呈现的是一样的：

```cmd
          (/)
        /    \
      (*)      (5)
    /    \
  (3)      (+)
          /   \
        (4)    (2)
```
